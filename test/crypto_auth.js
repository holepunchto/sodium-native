const test = require('brittle')
const sodium = require('..')

test('crypto_auth', function (t) {
  const key = Buffer.alloc(sodium.crypto_auth_KEYBYTES)
  sodium.randombytes_buf(key)

  const mac = Buffer.alloc(sodium.crypto_auth_BYTES)
  const value = Buffer.from('Hej, Verden')

  sodium.crypto_auth(mac, value, key)

  t.not(mac, Buffer.alloc(mac.length), 'mac not blank')
  t.absent(sodium.crypto_auth_verify(Buffer.alloc(mac.length), value, key), 'does not verify')
  t.ok(sodium.crypto_auth_verify(mac, value, key), 'verifies')
})

tape('crypto_auth #1', t => {
  // "Test Case 2" from RFC 4231
  const key = stringToArray('Jefe', 32)
  const c = stringToArray('what do ya want for nothing?')
  const c1 = stringToArray('wwhat do ya want for nothing')

  const a = new Uint8Array(sodium.crypto_auth_BYTES)

  const exp = [
    new Uint8Array([
      0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2,
      0xe3, 0x95, 0xfb, 0xe7, 0x3b, 0x56, 0xe0, 0xa3,
      0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6,
      0x10, 0x27, 0x0c, 0xd7, 0xea, 0x25, 0x05, 0x54
    ]),
    new Uint8Array([
      0x7b, 0x9d, 0x83, 0x38, 0xeb, 0x1e, 0x3d, 0xdd,
      0xba, 0x8a, 0x9a, 0x35, 0x08, 0xd0, 0x34, 0xa1,
      0xec, 0xbe, 0x75, 0x11, 0x37, 0xfa, 0x1b, 0xcb,
      0xa0, 0xf9, 0x2a, 0x3e, 0x6d, 0xfc, 0x79, 0x80
    ]),
    new Uint8Array([
      0xb9, 0xd1, 0x4c, 0x51, 0xa6, 0xd4, 0xdd, 0x41,
      0x60, 0x4e, 0xb0, 0x6c, 0x9c, 0x24, 0x0f, 0x1f,
      0x64, 0xf1, 0x43, 0xb5, 0xcf, 0xde, 0xa3, 0x71,
      0x29, 0xb2, 0x8b, 0xb7, 0x5d, 0x13, 0x71, 0xd3
    ])
  ]

  sodium.crypto_auth(a, c, key)
  t.deepEqual(a, exp[0])
  t.assert(sodium.crypto_auth_verify(exp[0], c, key))

  a.fill(0)
  sodium.crypto_auth(a, c1, key)
  t.deepEqual(a, exp[1])
  t.assert(sodium.crypto_auth_verify(exp[1], c1, key))

  // Empty message tests
  a.fill(0)
  sodium.crypto_auth(a, new Uint8Array(0), key)
  t.deepEqual(a, exp[2])
  t.assert(sodium.crypto_auth_verify(exp[2], new Uint8Array(0), key))
  t.end()
})

tape('crypto_auth', function (t) {
  const key = stringToArray('Jefe', 32)
  const c = stringToArray('what do ya want for nothing?')
  const a = new Uint8Array(sodium.crypto_auth_BYTES)
  const expected = new Uint8Array([
    0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2, 0xe3, 0x95, 0xfb, 0xe7,
    0x3b, 0x56, 0xe0, 0xa3, 0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6,
    0x10, 0x27, 0x0c, 0xd7, 0xea, 0x25, 0x05, 0x54
  ])

  sodium.crypto_auth(a, c, key)

  t.deepEqual(a, expected)
  t.ok(sodium.crypto_auth_verify(a, c, key))

  c[Math.floor(Math.random() * c.length)] += 1
  t.notOk(sodium.crypto_auth_verify(a, c, key))

  t.end()
})

tape('wrong keylength', t => {
  const a = new Uint8Array(32)
  const c = new Uint8Array(0)

  for (let i = 0; i < 128; i++) {
    if (i === 32) continue
    const k = new Uint8Array(i)
    try {
      sodium.crypto_auth(a, c, k)
      t.fail('failed on test #' + i)
    } catch (e) {
      try {
        sodium.crypto_auth_verify(a, c, k)
        t.fail('failed on test #' + i)
      } catch (e) {
        try {
          sodium.crypto_auth_verify(k, c, a)
          t.fail('failed on test #' + i)
        } catch {}
      }
    }
  }

  t.pass('should not accept bad input length')
  t.end()
})

tape('crypto_auth constants', t => {
  t.equal(sodium.crypto_auth_BYTES, 32)
  t.equal(sodium.crypto_auth_KEYBYTES, 32)
  t.end()
})

tape('rfc4231 test case #6', t => {
  const keys = [
    new Uint8Array([
      0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
      0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
      0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]),
    new Uint8Array([
      0x4a, 0x65, 0x66, 0x65, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]),
    new Uint8Array([
      0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
      0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
      0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]),
    new Uint8Array([
      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
      0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
      0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ])
  ]

  const data = [
    new Uint8Array([
      0x48, 0x69, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65
    ]),
    new Uint8Array([
      0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20,
      0x79, 0x61, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20,
      0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x68,
      0x69, 0x6e, 0x67, 0x3f
    ]),
    new Uint8Array([
      0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
      0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
      0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
      0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
      0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
      0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
      0xdd, 0xdd
    ]),
    new Uint8Array([
      0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
      0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
      0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
      0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
      0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
      0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd,
      0xcd, 0xcd
    ])
  ]

  const exp = [
    new Uint8Array([
      0x87, 0xaa, 0x7c, 0xde, 0xa5, 0xef, 0x61, 0x9d,
      0x4f, 0xf0, 0xb4, 0x24, 0x1a, 0x1d, 0x6c, 0xb0,
      0x23, 0x79, 0xf4, 0xe2, 0xce, 0x4e, 0xc2, 0x78,
      0x7a, 0xd0, 0xb3, 0x05, 0x45, 0xe1, 0x7c, 0xde
    ]),
    new Uint8Array([
      0x16, 0x4b, 0x7a, 0x7b, 0xfc, 0xf8, 0x19, 0xe2,
      0xe3, 0x95, 0xfb, 0xe7, 0x3b, 0x56, 0xe0, 0xa3,
      0x87, 0xbd, 0x64, 0x22, 0x2e, 0x83, 0x1f, 0xd6,
      0x10, 0x27, 0x0c, 0xd7, 0xea, 0x25, 0x05, 0x54
    ]),
    new Uint8Array([
      0xfa, 0x73, 0xb0, 0x08, 0x9d, 0x56, 0xa2, 0x84,
      0xef, 0xb0, 0xf0, 0x75, 0x6c, 0x89, 0x0b, 0xe9,
      0xb1, 0xb5, 0xdb, 0xdd, 0x8e, 0xe8, 0x1a, 0x36,
      0x55, 0xf8, 0x3e, 0x33, 0xb2, 0x27, 0x9d, 0x39
    ]),
    new Uint8Array([
      0xb0, 0xba, 0x46, 0x56, 0x37, 0x45, 0x8c, 0x69,
      0x90, 0xe5, 0xa8, 0xc5, 0xf6, 0x1d, 0x4a, 0xf7,
      0xe5, 0x76, 0xd9, 0x7f, 0xf9, 0x4b, 0x87, 0x2d,
      0xe7, 0x6f, 0x80, 0x50, 0x36, 0x1e, 0xe3, 0xdb
    ])
  ]

  const a = new Uint8Array(sodium.crypto_auth_BYTES)

  for (let i = 0; i < keys.length; i++) {
    sodium.crypto_auth(a, data[i], keys[i])
    t.same(a, exp[i])
    t.assert(sodium.crypto_auth_verify(exp[i], data[i], keys[i]))
  }

  t.end()
})

function stringToArray (s, size = s.length) {
  const array = new Uint8Array(size)
  array.set(s.split('').map((c) => c.charCodeAt(0)))
  return array
}
